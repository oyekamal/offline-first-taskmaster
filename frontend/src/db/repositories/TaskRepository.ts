/**
 * Task Repository - Implements repository pattern for Task entities
 *
 * Provides:
 * - Full CRUD operations with optimistic updates
 * - Local filtering, sorting, and pagination
 * - Sync queue management for offline operations
 * - Conflict detection and resolution
 * - Live query support through Dexie observables
 */

import { liveQuery } from 'dexie';
import { db, getDeviceId } from '../index';
import {
  Task,
  TaskFilters,
  TaskOrderBy,
  CreateTaskInput,
  UpdateTaskInput,
  SyncQueueEntry,
  SyncOperation
} from '../../types';

export class TaskRepository {
  /**
   * Create a new task locally
   * Adds to sync queue for eventual server sync
   */
  async create(input: CreateTaskInput): Promise<Task> {
    const deviceId = getDeviceId();
    const now = new Date().toISOString();

    const task: Task = {
      id: '', // Will be auto-generated by Dexie hook
      title: input.title,
      description: input.description,
      status: input.status,
      priority: input.priority,
      due_date: input.due_date || null,
      position: await this.getNextPosition(),
      assigned_to: input.assigned_to || null,
      assigned_to_name: null,
      tags: input.tags || [],
      custom_fields: input.custom_fields || {},
      version: 1,
      vector_clock: { [deviceId]: 1 },
      checksum: '', // Will be calculated by hook
      comment_count: 0,
      created_at: now,
      updated_at: now,
      deleted_at: null,
      _local_only: true,
      _sync_status: 'pending'
    };

    const id = await db.tasks.add(task);
    const createdTask = await db.tasks.get(id);

    if (!createdTask) {
      throw new Error('Failed to create task');
    }

    // Add to sync queue
    await this.addToSyncQueue(createdTask.id, 'CREATE', createdTask);

    return createdTask;
  }

  /**
   * Get a single task by ID
   */
  async get(id: string): Promise<Task | undefined> {
    return await db.tasks.get(id);
  }

  /**
   * Update a task with optimistic update
   */
  async update(id: string, updates: UpdateTaskInput): Promise<Task> {
    const existing = await db.tasks.get(id);
    if (!existing) {
      throw new Error('Task not found');
    }

    // Perform optimistic update
    await db.tasks.update(id, {
      ...updates,
      _sync_status: 'pending'
    });

    const updated = await db.tasks.get(id);
    if (!updated) {
      throw new Error('Failed to update task');
    }

    // Add to sync queue
    await this.addToSyncQueue(id, 'UPDATE', updates);

    return updated;
  }

  /**
   * Soft delete a task (sets deleted_at)
   */
  async delete(id: string): Promise<void> {
    const task = await db.tasks.get(id);
    if (!task) {
      throw new Error('Task not found');
    }

    await db.tasks.update(id, {
      deleted_at: new Date().toISOString(),
      _sync_status: 'pending'
    });

    // Add to sync queue
    await this.addToSyncQueue(id, 'DELETE', { deleted_at: new Date().toISOString() });
  }

  /**
   * Permanently delete a task from local database
   */
  async hardDelete(id: string): Promise<void> {
    await db.tasks.delete(id);
    // Remove from sync queue
    await db.sync_queue.where('entity_id').equals(id).delete();
  }

  /**
   * List tasks with filters, sorting, and pagination
   */
  async list(
    filters?: TaskFilters,
    orderBy: TaskOrderBy = 'position',
    limit = 50,
    offset = 0
  ): Promise<Task[]> {
    let query = db.tasks.orderBy(this.getOrderField(orderBy));

    // Apply filters
    if (filters?.status) {
      const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];
      query = query.filter(task => statuses.includes(task.status));
    }

    if (filters?.priority) {
      const priorities = Array.isArray(filters.priority) ? filters.priority : [filters.priority];
      query = query.filter(task => priorities.includes(task.priority));
    }

    if (filters?.assigned_to) {
      query = query.filter(task => task.assigned_to === filters.assigned_to);
    }

    if (filters?.tags && filters.tags.length > 0) {
      query = query.filter(task =>
        filters.tags!.some(tag => task.tags.includes(tag))
      );
    }

    if (filters?.search) {
      const searchLower = filters.search.toLowerCase();
      query = query.filter(task =>
        task.title.toLowerCase().includes(searchLower) ||
        task.description.toLowerCase().includes(searchLower)
      );
    }

    // Hide deleted unless explicitly requested
    if (!filters?.show_deleted) {
      query = query.filter(task => !task.deleted_at);
    }

    // Apply pagination
    const results = await query.offset(offset).limit(limit).toArray();

    // Apply reverse ordering if needed
    if (orderBy.startsWith('-')) {
      results.reverse();
    }

    return results;
  }

  /**
   * Count tasks matching filters
   */
  async count(filters?: TaskFilters): Promise<number> {
    const tasks = await this.list(filters, 'position', 10000, 0);
    return tasks.length;
  }

  /**
   * Get tasks as live query (auto-updates on changes)
   */
  liveQuery(filters?: TaskFilters, orderBy: TaskOrderBy = 'position') {
    return liveQuery(() => this.list(filters, orderBy, 1000));
  }

  /**
   * Update task position for drag-and-drop reordering
   */
  async updatePosition(id: string, newPosition: number): Promise<void> {
    await this.update(id, { position: newPosition });
  }

  /**
   * Bulk update tasks
   */
  async bulkUpdate(ids: string[], updates: UpdateTaskInput): Promise<void> {
    await db.transaction('rw', db.tasks, db.sync_queue, async () => {
      for (const id of ids) {
        await this.update(id, updates);
      }
    });
  }

  /**
   * Search tasks locally
   */
  async search(query: string, limit = 20): Promise<Task[]> {
    return this.list({ search: query }, 'updated_at', limit);
  }

  /**
   * Get tasks by status
   */
  async getByStatus(status: string): Promise<Task[]> {
    return db.tasks
      .where('status')
      .equals(status)
      .and(task => !task.deleted_at)
      .toArray();
  }

  /**
   * Get tasks due soon (within specified days)
   */
  async getDueSoon(days = 7): Promise<Task[]> {
    const now = new Date();
    const future = new Date(now.getTime() + days * 24 * 60 * 60 * 1000);

    return db.tasks
      .where('due_date')
      .between(now.toISOString(), future.toISOString(), true, true)
      .and(task => !task.deleted_at && task.status !== 'done')
      .toArray();
  }

  /**
   * Get overdue tasks
   */
  async getOverdue(): Promise<Task[]> {
    const now = new Date().toISOString();

    return db.tasks
      .where('due_date')
      .below(now)
      .and(task => !task.deleted_at && task.status !== 'done' && task.due_date !== null)
      .toArray();
  }

  /**
   * Sync task from server (used by sync manager)
   */
  async syncFromServer(task: Task): Promise<void> {
    const existing = await db.tasks.get(task.id);

    if (!existing) {
      // New task from server
      await db.tasks.add({
        ...task,
        _local_only: false,
        _conflict: false,
        _sync_status: 'synced'
      });
    } else {
      // Check for conflicts using vector clocks
      const hasConflict = this.detectConflict(existing.vector_clock, task.vector_clock);

      if (hasConflict) {
        // Mark as conflict for user resolution
        await db.tasks.update(task.id, {
          _conflict: true,
          _sync_status: 'conflict'
        });
      } else {
        // Server version is newer, accept it and clear any conflict flags
        await db.tasks.put({
          ...task,
          _local_only: false,
          _conflict: false,
          _sync_status: 'synced'
        });
      }
    }
  }

  /**
   * Mark task as successfully synced
   */
  async markSynced(id: string): Promise<void> {
    await db.tasks.update(id, {
      _local_only: false,
      _sync_status: 'synced'
    });

    // Remove from sync queue
    await db.sync_queue
      .where('entity_id')
      .equals(id)
      .delete();
  }

  /**
   * Private helper: Add operation to sync queue
   */
  private async addToSyncQueue(
    entityId: string,
    operation: SyncOperation,
    data: Partial<Task>
  ): Promise<void> {
    const deviceId = getDeviceId();
    const entry: SyncQueueEntry = {
      id: '', // Auto-generated
      entity_type: 'task',
      entity_id: entityId,
      operation,
      data,
      vector_clock: { [deviceId]: Date.now() },
      attempt_count: 0,
      last_attempt_at: null,
      created_at: new Date().toISOString(),
      error_message: null
    };

    await db.sync_queue.add(entry);
  }

  /**
   * Private helper: Detect conflicts using vector clocks
   */
  private detectConflict(localClock: Record<string, number>, serverClock: Record<string, number>): boolean {
    // Simple conflict detection:
    // If neither clock dominates the other, there's a conflict

    let localDominates = false;
    let serverDominates = false;

    const allDevices = new Set([...Object.keys(localClock), ...Object.keys(serverClock)]);

    for (const device of allDevices) {
      const localTime = localClock[device] || 0;
      const serverTime = serverClock[device] || 0;

      if (localTime > serverTime) localDominates = true;
      if (serverTime > localTime) serverDominates = true;
    }

    // Conflict exists if both clocks have some dominance
    return localDominates && serverDominates;
  }

  /**
   * Private helper: Get next position for new tasks
   */
  private async getNextPosition(): Promise<number> {
    const lastTask = await db.tasks
      .orderBy('position')
      .reverse()
      .first();

    return lastTask ? lastTask.position + 1 : 1;
  }

  /**
   * Private helper: Map order field to database field
   */
  private getOrderField(orderBy: TaskOrderBy): string {
    return orderBy.replace('-', '');
  }
}

// Export singleton instance
export const taskRepository = new TaskRepository();
